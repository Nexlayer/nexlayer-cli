package template

import (
	"bytes"
	"text/template"

	"github.com/Nexlayer/nexlayer-cli/pkg/commands/types"
)

// Templates for different application types
const (
	// MERN stack template
	MERNTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: mern

resources:
    memory: 512Mi
    cpu: 0.5
    storage: 1Gi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPU: 80

deployment:
    env:
      NODE_ENV: production
      MONGODB_URI: ${MONGODB_URI}
    ports:
      - 3000
    healthCheck:
      path: /health
      port: 3000`

	// Python Flask template
	FlaskTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: flask

resources:
    memory: 256Mi
    cpu: 0.2
    storage: 500Mi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPU: 80

deployment:
    env:
      FLASK_ENV: production
    ports:
      - 5000
    healthCheck:
      path: /health
      port: 5000`

	// Go template
	GoTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: go

resources:
    memory: 256Mi
    cpu: 0.2
    storage: 500Mi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPU: 80

deployment:
    env:
      GO_ENV: production
    ports:
      - 8080
    healthCheck:
      path: /health
      port: 8080`

	// Kubeflow template
	KubeflowTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: kubeflow
  framework: kubeflow

resources:
    memory: 512Mi
    cpu: 0.5
    storage: 1Gi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPU: 80

deployment:
    env:
      PIPELINE_NAME: ${PIPELINE_NAME}
      PIPELINE_VERSION: ${PIPELINE_VERSION}
    ports:
      - 8080
    healthCheck:
      path: /health
      port: 8080`
)

// TemplateData holds data for template rendering
type TemplateData struct {
	AppName     string
	MONGODB_URI string
	FLASK_ENV   string
	GO_ENV      string
	PIPELINE_NAME string
	PIPELINE_VERSION string
}

// RenderTemplate renders a template with the given data
func RenderTemplate(tmpl string, data TemplateData) (string, error) {
	t, err := template.New("template").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}

// CreateKubeflowConfig creates a Kubeflow pipeline template configuration
func CreateKubeflowConfig(projectName string) types.Config {
	config := types.Config{
		Application: types.Application{
			Template: types.Template{
				Name:           projectName,
				DeploymentName: projectName,
				RegistryLogin: types.RegistryAuth{
					Registry:            "ghcr.io",
					Username:           "<Github username>",
					PersonalAccessToken: "<Github Packages Read-Only PAT>",
				},
				Pods: []types.PodConfig{
					{
						Type: "llm",
						Name: "kubeflow",
						Tag:  "latest",
						Vars: []types.VarPair{
							{
								Key:   "PIPELINE_NAME",
								Value: projectName,
							},
							{
								Key:   "PIPELINE_VERSION",
								Value: "1.0.0",
							},
						},
					},
				},
			},
		},
	}
	return config
}
