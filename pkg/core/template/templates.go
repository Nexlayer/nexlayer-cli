package templates

import (
	"bytes"
	"text/template"
)

// Templates for different application types
const (
	// MERN stack template
	MERNTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: mern

resources:
    memory: 512Mi
    cpu: 0.5
    storage: 1Gi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 5
    targetCPU: 80

deployment:
    env:
      NODE_ENV: production
      MONGODB_URI: ${MONGODB_URI}
    ports:
      - 3000
    healthCheck:
      path: /health
      port: 3000`

	// Python Flask template
	FlaskTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: flask

resources:
    memory: 256Mi
    cpu: 0.2
    storage: 500Mi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPU: 80

deployment:
    env:
      FLASK_ENV: production
    ports:
      - 5000
    healthCheck:
      path: /health
      port: 5000`

	// Go template
	GoTemplate = `# Generated by Nexlayer CLI
version: '1.0'
app:
  name: ${APP_NAME}
  type: web
  framework: go

resources:
    memory: 256Mi
    cpu: 0.2
    storage: 500Mi

scaling:
    enabled: true
    minReplicas: 1
    maxReplicas: 3
    targetCPU: 80

deployment:
    env:
      GO_ENV: production
    ports:
      - 8080
    healthCheck:
      path: /health
      port: 8080`
)

// TemplateData holds data for template rendering
type TemplateData struct {
	AppName     string
	MONGODB_URI string
	FLASK_ENV   string
	GO_ENV      string
}

// RenderTemplate renders a template with the given data
func RenderTemplate(tmpl string, data TemplateData) (string, error) {
	t, err := template.New("template").Parse(tmpl)
	if err != nil {
		return "", err
	}

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return "", err
	}

	return buf.String(), nil
}
